
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scarlet.operator &#8212; scarlet  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="canonical" href="api/api/scarlet.operator.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="scarlet.parameter" href="scarlet.parameter.html" />
    <link rel="prev" title="scarlet.observation" href="scarlet.observation.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0-quickstart.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1-concepts.html">Core Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="scarlet.html">API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scarlet.bbox.html">scarlet.bbox</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.blend.html">scarlet.blend</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.cache.html">scarlet.cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.component.html">scarlet.component</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.constraint.html">scarlet.constraint</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.display.html">scarlet.display</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.fft.html">scarlet.fft</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.frame.html">scarlet.frame</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.initialization.html">scarlet.initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.interpolation.html">scarlet.interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.measure.html">scarlet.measure</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.model.html">scarlet.model</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.morphology.html">scarlet.morphology</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.observation.html">scarlet.observation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">scarlet.operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.parameter.html">scarlet.parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.prior.html">scarlet.prior</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.psf.html">scarlet.psf</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.source.html">scarlet.source</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.spectrum.html">scarlet.spectrum</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.wavelet.html">scarlet.wavelet</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../regression.html">Regression Testing</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-scarlet.operator">
<span id="scarlet-operator"></span><h1>scarlet.operator<a class="headerlink" href="#module-scarlet.operator" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="scarlet.operator.diagonalizeArray">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">diagonalizeArray</code><span class="sig-paren">(</span><em class="sig-param">arr</em>, <em class="sig-param">shape=None</em>, <em class="sig-param">dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#diagonalizeArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.diagonalizeArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array to a matrix that compares each pixel to its neighbors
Given an array with length N, create an 8xN array, where each row will be a
diagonal in a diagonalized array. Each column in this matrix is a row in the larger
NxN matrix used for an operator, except that this 2D array only contains the values
used to create the bands in the band diagonal matrix.
Because the off-diagonal bands have less than N elements, <code class="docutils literal notranslate"><span class="pre">getOffsets</span></code> is used to
create a mask that will set the elements of the array that are outside of the matrix to zero.
<code class="docutils literal notranslate"><span class="pre">arr</span></code> is the vector to diagonalize, for example the distance from each pixel to the peak,
or the angle of the vector to the peak.
<code class="docutils literal notranslate"><span class="pre">shape</span></code> is the shape of the original image.</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.diagonalsToSparse">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">diagonalsToSparse</code><span class="sig-paren">(</span><em class="sig-param">diagonals</em>, <em class="sig-param">shape</em>, <em class="sig-param">dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#diagonalsToSparse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.diagonalsToSparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a diagonalized array into a sparse diagonal matrix
<code class="docutils literal notranslate"><span class="pre">diagonalizeArray</span></code> creates an 8xN array representing the bands that describe the
interactions of a pixel with its neighbors. This function takes that 8xN array and converts
it into a sparse diagonal matrix.
See <cite>diagonalizeArray</cite> for the details of the 8xN array.</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.find_Q">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">find_Q</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Vs</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#find_Q"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.find_Q" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a Q that is within the solution space that can act as an appropriate target
(could be rigorously constructed later)</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.find_relevant_dim">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">find_relevant_dim</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Y</span></em>, <em class="sig-param"><span class="n">Q</span></em>, <em class="sig-param"><span class="n">Vs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#find_relevant_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.find_relevant_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a dimension relevant to the problem by ‘raycasting’ from Y to Q</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.getOffsets">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">getOffsets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">coords</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#getOffsets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.getOffsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the offset and slices for a sparse band diagonal array
For an operator that interacts with its neighbors we want a band diagonal matrix,
where each row describes the 8 pixels that are neighbors for the reference pixel
(the diagonal). Regardless of the operator, these 8 bands are always the same,
so we make a utility function that returns the offsets (passed to scipy.sparse.diags).
See <cite>diagonalizeArray</cite> for more on the slices and format of the array used to create
NxN operators that act on a data vector.</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.getRadialMonotonicWeights">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">getRadialMonotonicWeights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">neighbor_weight</span><span class="o">=</span><span class="default_value">'flat'</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#getRadialMonotonicWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.getRadialMonotonicWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the weights used for the Radial Monotonicity Operator
This version of the radial monotonicity operator selects all of the pixels closer to the peak
for each pixel and weights their flux based on their alignment with a vector from the pixel
to the peak. In order to quickly create this using sparse matrices, its construction is a bit opaque.</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.proj">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the projection of A onto the hyper-plane defined by B</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.proj_dist">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">proj_dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#proj_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.proj_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns length of projection of A onto B</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.project_disk_sed">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">project_disk_sed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bulge_sed</span></em>, <em class="sig-param"><span class="n">disk_sed</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#project_disk_sed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.project_disk_sed" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the disk SED onto the space where it is bluer</p>
<p>For the majority of observed galaxies, it appears that
the difference between the bulge and the disk SEDs is
roughly monotonic, making the disk bluer.</p>
<p>This projection operator projects colors that are redder onto
the same difference in color as the previous wavelength,
similar to the way monotonicity works for the morphological
<cite>S</cite> matrix of the model.</p>
<p>While a single iteration of this model is unlikely to yield
results that are as good as those in <cite>project_disk_sed_mean</cite>,
after many iterations it is expected to converge to a better value.</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.project_disk_sed_mean">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">project_disk_sed_mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bulge_sed</span></em>, <em class="sig-param"><span class="n">disk_sed</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#project_disk_sed_mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.project_disk_sed_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the disk SED onto the space where it is bluer</p>
<p>For the majority of observed galaxies, it appears that
the difference between the bulge and the disk SEDs is
roughly monotonic, making the disk bluer.</p>
<p>This projection operator projects colors that are redder
than other colors onto the average SED difference for
that wavelength. This is a more accurate SED than
<cite>project_disk_sed</cite> but is more likely to create
discontinuities in the evaluation of A, and should
probably be avoided. It is being kept for now to record
its effect.</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.prox_cone">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">prox_cone</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_cone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.prox_cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Exact projection of components of X onto cone defined by Gx &gt;= 0</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.prox_kspace_symmetry">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">prox_kspace_symmetry</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">shift</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">10</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_kspace_symmetry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.prox_kspace_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetry in Fourier Space</p>
<p>This algorithm by Nate Lust uses the fact that throwing
away the imaginary part in Fourier space leaves a symmetric
soution in real space. So <cite>X</cite> is transformed to Fourier space,
shifted by the fractional amount <cite>shift=(dy, dx)</cite>,
the imaginary part is discarded, shited back to its original position,
then transformed back to real space.</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.prox_sdss_symmetry">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">prox_sdss_symmetry</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">step</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_sdss_symmetry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.prox_sdss_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>SDSS/HSC symmetry operator</p>
<p>This function uses the <em>minimum</em> of the two
symmetric pixels in the update.</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.prox_soft_symmetry">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">prox_soft_symmetry</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">strength</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_soft_symmetry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.prox_soft_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Soft version of symmetry
Using a <cite>strength</cite> that varies from 0 to 1,
with 0 meaning no symmetry enforced at all and
1  being completely symmetric, the user can customize
the level of symmetry required for a component</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.prox_uncentered_symmetry">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">prox_uncentered_symmetry</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">algorithm</span><span class="o">=</span><span class="default_value">'kspace'</span></em>, <em class="sig-param"><span class="n">fill</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shift</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">strength</span><span class="o">=</span><span class="default_value">0.5</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_uncentered_symmetry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.prox_uncentered_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetry with off-center peak</p>
<p>Symmetrize X for all pixels with a symmetric partner.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>X: array</strong></dt><dd><p>The parameter to update.</p>
</dd>
<dt><strong>step: `int`</strong></dt><dd><p>Step size of the gradient step.</p>
</dd>
<dt><strong>center: tuple of `int`</strong></dt><dd><p>The center pixel coordinates to apply the symmetry operator.</p>
</dd>
<dt><strong>algorithm: `string`</strong></dt><dd><p>The algorithm to use for symmetry.
* If <cite>algorithm = “kspace” then `X</cite> is shifted by <cite>shift</cite> and</p>
<blockquote>
<div><p>symmetry is performed in kspace. This is the only symmetry algorithm
in scarlet that works for fractional pixel shifts.</p>
</div></blockquote>
<ul class="simple">
<li><p>If <cite>algorithm = “sdss” then the SDSS symmetry is used,
namely the source is made symmetric around the `center</cite> pixel
by taking the minimum of each pixel and its symmetric partner.
This is the algorithm used when initializing an <cite>ExtendedSource</cite>
because it keeps the morphologies small, but during optimization
the penalty is much stronger than the gradient
and often leads to vanishing sources.</p></li>
<li><p>If <cite>algorithm = “soft” then soft symmetry is used,
meaning `X</cite> will be allowed to differ from symmetry by the fraction
<cite>strength</cite> from a perfectly symmetric solution. It is advised against
using this algorithm because it does not work in general for sources
shifted by a fractional amount, however it is used internally if
a source is centered perfectly on a pixel.</p></li>
</ul>
</dd>
<dt><strong>fill: `float`</strong></dt><dd><p>The value to fill the region that cannot be made symmetric.
When <cite>fill</cite> is <cite>None</cite> then the region of <cite>X</cite> that is not symmetric
is not constrained.</p>
</dd>
<dt><strong>strength: `float`</strong></dt><dd><p>The amount that symmetry is enforced. If <cite>strength=0</cite> then no
symmetry is enforced, while <cite>strength=1</cite> enforces strict symmetry
(ie. the mean of the two symmetric pixels is used for both of them).
This parameter is only used when <cite>algorithm = “soft”</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: <cite>function</cite></dt><dd><p>The update function based on the specified parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.prox_weighted_monotonic">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">prox_weighted_monotonic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">neighbor_weight</span><span class="o">=</span><span class="default_value">'flat'</span></em>, <em class="sig-param"><span class="n">min_gradient</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_weighted_monotonic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.prox_weighted_monotonic" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the prox_monotonic operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>neighbor_weight: [‘flat’, ‘angle’, ‘nearest’]</strong></dt><dd><p>Which weighting scheme to average all neighbor pixels towards <cite>center</cite>
as reference for the monotonicty test.</p>
</dd>
<dt><strong>min_gradient: `float`</strong></dt><dd><p>Forced gradient. A <cite>thresh</cite> of zero will allow a pixel to be the
same value as its reference pixels, while a <cite>thresh</cite> of one
will force the pixel to zero.</p>
</dd>
<dt><strong>center: tuple</strong></dt><dd><p>Location of the central (highest-value) pixel.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: <cite>function</cite></dt><dd><p>The monotonicity function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.proximal_disk_sed">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">proximal_disk_sed</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">step</em>, <em class="sig-param">peaks</em>, <em class="sig-param">algorithm=&lt;function project_disk_sed_mean&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#proximal_disk_sed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.proximal_disk_sed" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that each disk SED is bluer than the bulge SED</p>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.sort_by_radius">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">sort_by_radius</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#sort_by_radius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.sort_by_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort indices distance from the center</p>
<p>Given a shape, calculate the distance of each
pixel from the center and return the indices
of each pixel, sorted by radial distance from
the center, which need not be in the center
of the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape: `tuple`</strong></dt><dd><p>Shape (y,x) of the source frame.</p>
</dd>
<dt><strong>center: array-like</strong></dt><dd><p>Location of the center pixel.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>didx: <cite>~numpy.array</cite></dt><dd><p>Indices of elements in an image with shape <cite>shape</cite>,
sorted by distance from the center.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.uncentered_operator">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">uncentered_operator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#uncentered_operator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.uncentered_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Only apply the operator on a centered patch</p>
<p>In some cases, for example symmetry, an operator might not make
sense outside of a centered box. This operator only updates
the portion of <cite>X</cite> inside the centered region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X: array</strong></dt><dd><p>The parameter to update.</p>
</dd>
<dt><strong>func: `function`</strong></dt><dd><p>The function (or operator) to apply to <cite>X</cite>.</p>
</dd>
<dt><strong>center: tuple</strong></dt><dd><p>The location of the center of the sub-region to
apply <cite>func</cite> to <cite>X</cite>.</p>
</dd>
<dt><strong>`fill`: `float`</strong></dt><dd><p>The value to fill the region outside of centered
<cite>sub-region</cite>, for example <cite>0</cite>. If <cite>fill</cite> is <cite>None</cite>
then only the subregion is updated and the rest of
<cite>X</cite> remains unchanged.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="scarlet.operator.use_relevant_dim">
<code class="sig-prename descclassname">scarlet.operator.</code><code class="sig-name descname">use_relevant_dim</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Y</span></em>, <em class="sig-param"><span class="n">Q</span></em>, <em class="sig-param"><span class="n">Vs</span></em>, <em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#use_relevant_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scarlet.operator.use_relevant_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses relevant dimension to reduce problem dimensionality (projects everything onto the
new hyperplane</p>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2018-2019, Fred Moolekamp and Peter Melchior.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/api/scarlet.operator.rst"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>